<?xml version="1.0" encoding="UTF-8"?>
<wxgrammar_generator_file lang="cpp">
	<var name="header_doc">
/** @file $(filename).h
 * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
 * @date $(date)
 */
	</var>
	<var name="src_doc">
/** @file $(filename).cpp
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
	</var>
	<var name="extended_enumeration_hdr">
/** @class wxExtendedEnumeration
  * @brief Main class from which any enumeration class shall derive from
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
class wxExtendedEnumeration : public wxExtendedObject
{
	DECLARE_ABSTRACT_CLASS( wxExtendedEnumeration )
	
public :
	
	/** Get values all childrens must overload this method */
	virtual const wxString* GetValues() const = 0;
	
	/** Get enumerated as a wxArrayInt */
	virtual std::vector&lt;unsigned int&gt; GetFlags() const = 0;
	
	/** Get the total number of enumerated values */
	virtual unsigned int GetCount() const = 0;
	
	/** Get the value from the flag */
	virtual const wxString&amp; GetFromFlag( unsigned int value ) const = 0;
	
	/** get the falg from value */
	virtual unsigned int GetUIntFromValue( const wxString&amp; value ) const = 0;
	
	/** get the flag */
	virtual unsigned int GetUIntFlag() const = 0;
	
	/** get the value */
	virtual const wxString&amp; GetValue() const = 0;
	
	/** Set the value */
	virtual void SetFlag( unsigned int value ) = 0;
	
	/** Set the value */
	virtual void SetValue( const wxString&amp; value ) = 0;

};
	</var>
	<var name="extended_enumeration_src">
/** Implement the wxWidgets RTTI dynamic calss information */
IMPLEMENT_ABSTRACT_CLASS( wxExtendedEnumeration , wxExtendedObject )
	</var>
	<var name="base_object">wxExtendedObject</var>
	<var name="variant_overloads">
/* Overloads of operator &lt;&lt; for standard variant types */
inline void operator&lt;&lt;( wxString&amp; str , const wxVariant&amp; var )
{
	str = var.GetString();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const wxString&amp; str )
{
	var = str;
}

inline void operator&lt;&lt;( bool&amp; str , const wxVariant&amp; var )
{
	str = var.GetBool();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const bool&amp; str )
{
	var = str;
}

inline void operator&lt;&lt;( int&amp; str , const wxVariant&amp; var )
{
	str = (int) var.GetLong();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const int&amp; str )
{
	var = (long) str;
}

inline void operator&lt;&lt;( unsigned int&amp; str , const wxVariant&amp; var )
{
	str = (unsigned int) var.GetLong();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const unsigned int&amp; str )
{
	var = (long) str;
}

inline void operator&lt;&lt;( double&amp; str , const wxVariant&amp; var )
{
	str = var.GetDouble();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const double&amp; str )
{
	var = str;
}

inline void operator&lt;&lt;( long&amp; str , const wxVariant&amp; var )
{
	str = var.GetLong();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const long&amp; str )
{
	var = str;
}

inline void operator&lt;&lt;( unsigned long&amp; str , const wxVariant&amp; var )
{
	str = (unsigned long) var.GetLong();
}

inline void operator&lt;&lt;( wxVariant&amp; var , const unsigned long&amp; str )
{
	var = (long) str;
}
	</var>
	<var name="string_composer">wxT("$(content)")</var>
	<var name="ctor_var_composer"> const $(content_type)&amp; $(content)</var>
	<var name="ctor_var_composer2"> $(content)</var>
	<var name="var_eqop_composer">	m_$(content) = rhs.m_$(content);
	m_has$(content) = rhs.m_has$(content);
	</var>
	<var name="var_eqeqop_composer">m_$(content) == rhs.m_$(content)</var>
	<var name="var_property_composer">	wxgPROPERTY(Set$(content_ext),Get$(content_ext),$(content),$(content_type),wxT("Property for $(content) of type $(content_type)"))
	wxgPROPERTY(SetHas$(content_ext),Has$(content_ext),has$(content),bool,wxT("Property checker for $(content) of type $(content_type)"))</var>
	<var name="var_definit_composer">,
			m_has$(content)(false)</var>
	<var name="var_init_composer">,
			m_$(content)($(content)),
			m_has$(content)(true)</var>
	<var name="var_copy_composer">,
			m_$(content)(rhs.m_$(content)),
			m_has$(content)(rhs.m_has$(content))</var>
	<var name="var_doc_composer">
	  * @param $(content) value for $(content) property of type $(content_type)</var>
	<var name="ext_eqop_composer">	if( m_$(content) != NULL ) {
		delete m_$(content);
		m_$(content) = NULL;
		m_has$(content) = false;
	}
	
	if( rhs.m$(content) != NULL ) {
		m_$(content) = rhs.m_$(content)->Clone();
		m_has$(content) = true;
	}
	</var>
	<var name="ext_dtor_composer">	if( m_$(content) != NULL ) {
		delete m_$(content);
		m_$(content) = NULL;
		m_has$(content) = false;
	}</var>
	<var name="ext_init_composer">,
		m_$(content)(NULL)</var>
	<var name="namespace_start">
namespace $(ns) {
	</var>
	<var name="globals_start">
$(header_doc)
#ifndef $(ns)_globals_H
#define $(ns)_globals_H

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include &lt;wx/wx.h&gt;
#include &lt;wx/log.h&gt;
#include &lt;wx/any.h&gt;
#include &lt;wx/string.h&gt;
#include &lt;set&gt;
#include &lt;string&gt;

#include "wxgDefines.h"
#include "wxgException.h"
#include "wxDuration.h"
#include "wxExtendedObject.h"
#include "wxExtendedObjectFactory.h"

#define $(exportmacro)

// the next is for reading conventions for the different formats !
/** define a wxDate object */
typedef wxDateTime wxDate;
/** define a wxTime object */
typedef wxDateTime wxTime;
/** define a wxYear object */
typedef wxDateTime wxYear;
/** define a wxYearMonth object */
typedef wxDateTime wxYearMonth;
/** define a wxMonth object */
typedef wxDateTime wxMonth;
/** define a wxMonthDay object */
typedef wxDateTime wxMonthDay;

	</var>
	<var name="globals_end">

#endif // $(ns)_globals_H
	</var>
	<var name="global_file_src">
/** @file $(ns)_globals.cpp
  * @breif Main file for implementing globals informations
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
#include "$(ns)_globals.h"

$(globals_code_src)
	</var>
	<var name="global_file">
$(globals_start)

$(globals_code)

$(globals_end)
	</var>
	<var name="namespace_end">
};
	</var>
	<var name="object_defines">
#ifndef $(OBJECT)_H
#define $(OBJECT)_H
	</var>
	<var name="object_defines_end">
#endif // $(OBJECT)_H
	</var>
	<var name="object_simple_ctor_header">
	/** Default Constructor */
	$(object)():
$(object_bases_default_ctor)
	{};
	</var>
	<var name="object_complex_ctor_header">
	/** Default Constructor */
	$(object)():
$(object_bases_default_ctor) $(parameters_default_init_list)
	{};

	/** Basic Constructor $(parameters_doc_list)
	  */
	$(object)($(parameters_ctor_list)):
$(object_bases_init_list) $(parameters_init_list)
	{};
	</var>
	<template name="object">
		<objectpart file="header">
$(header_doc)

$(object_defines)

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include &lt;wx/wx.h&gt;
#include &lt;wx/log.h&gt;
#include &lt;wx/variant.h&gt;

$(local_includes)

/** preliminary define to enable the variant definition for that object */
$(object_imports)

DECLARE_VARIANT_OBJECT($(object))

/** @class $(object)
  * @brief Main class for handling $(object) nodes information in xml files
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
class $(exportmacro) $(object) : $(object_bases)
{
	DECLARE_DYNAMIC_CLASS( $(object) )
public :
	/**********************************************************************
  	 * CONSTRUCTORS
	 *********************************************************************/

$(object_ctors)

	/** Copy constructor */
	$(object)( const $(object)&amp; rhs ):
$(object_bases_copy_list) $(parameters_copy_list)
	{};
	
	/** Clone method that any child must overload in order to enable the copy
	 * from the base object */
	virtual $(base_object)* Clone() {return new $(object)(*(this));}
	
	/** default destructor */
	virtual ~$(object)();
	
	/**********************************************************************
  	 * OPERATORS OVERLOAD
	 *********************************************************************/
	
	/** operator= overload */
	$(object)&amp; operator=( const $(object)&amp; rhs );

	/** operator== overload */
	bool operator==( const $(object)&amp; rhs ) const;

	/**********************************************************************
  	 * METHODS
	 *********************************************************************/
	
$(childs_header_public_code)

private :
$(childs_header_private_code)
	wxgDECLARE_PROPERTY_TABLE( $(object) , $(object_bases_list) )
protected:
$(childs_header_protected_code)
};

$(object_defines_end)
		</objectpart>
		<objectpart file="src">
$(src_doc)

#include "$(object).h"

IMPLEMENT_DYNAMIC_CLASS( $(object) , $(object_bases_list) )
IMPLEMENT_VARIANT_OBJECT($(object))

wxgBEGIN_PROPERTY_TABLE($(object),wxT("Main class for handling $(object) nodes from XML files") )
$(parameters_property_table)
wxgEND_PROPERTY_TABLE()

$(object)::~$(object)() {
$(parameters_dtor_list)
}

$(object)&amp; $(object)::operator=( const $(object)&amp; rhs )
{
$(parameters_eqop_list)

	return (*this);
}

bool $(object)::operator==( const $(object)&amp; rhs ) const
{
	return  (
$(parameters_eqeqop_list)
	 	);
}

$(childs_src_code)

		</objectpart>
	</template>
	<template name="property">
		<objectpart file="header" permission="protected">	$(type) m_$(name);
	bool m_has$(name);
</objectpart>
		<objectpart file="header" permission="public">
	/** Set the $(name) property
  	  * @param $(name) property value to set
  	  */
	void Set$(name_extension)( const $(type)&amp; $(name) );

	/** Get the $(name) property
  	  * @return The property value as a $(type) object
	  */
	$(type)&amp; Get$(name_extension)( );
	
	/** Set the property $(name) has used */
	void SetHas$(name_extension)(bool value = true) {
		m_has$(name) = value;
	}
	
	/** Check if the object has the $(name) property set */
	bool Has$(name_extension)() const { return m_has$(name);};
	
	/** declare the property as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY( Set$(name_extension) , Get$(name_extension) , $(name) , $(type) )
	
	/** declare the property checker as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY_CHECKER( SetHas$(name_extension) , Has$(name_extension) , has$(name) , bool )
		</objectpart>
		<objectpart file="src">
void $(object)::Set$(name_extension)( const $(type)&amp; $(name) )
{
	m_$(name) = $(name);
	m_has$(name) = true;
}

$(type)&amp; $(object)::Get$(name_extension)( )
{
	return m_$(name);
}
		</objectpart>
	</template>
	<template name="attribute">
		<objectpart file="header" permission="protected">	$(type) m_$(name);
	bool m_has$(name);
</objectpart>
		<objectpart file="header" permission="public">
	/** Set the $(name) property
  	  * @param $(name) property value to set
  	  */
	void Set$(name_extension)( const $(type)&amp; $(name) );

	/** Get the $(name) property
  	  * @return The property value as a $(type) object
	  */
	$(type)&amp; Get$(name_extension)( );
	
	/** Set the property $(name) has used */
	void SetHas$(name_extension)(bool value = true) {
		m_has$(name) = value;
	}
	
	/** Check if the object has the $(name) property set */
	bool Has$(name_extension)() const {return m_has$(name);};
	
	/** declare the property as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY( Set$(name_extension) , Get$(name_extension) , $(name) , $(type) )
	
	/** declare the property checker as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY_CHECKER( SetHas$(name_extension) , Has$(name_extension) , has$(name) , bool )
		</objectpart>
		<objectpart file="src">
void $(object)::Set$(name_extension)( const $(type)&amp; $(name) )
{
	m_$(name) = $(name);
	m_has$(name) = true;
}

$(type)&amp; $(object)::Get$(name_extension)( )
{
	return m_$(name);
}
		</objectpart>
	</template>
	<template name="property_any">
		<objectpart file="header" permission="protected">	$(type)* m_$(name);
	bool m_has$(name);
</objectpart>
		<objectpart file="header" permission="public">
	/** Set the $(name) property
  	  * @param $(name) property value to set
  	  */
	void Set$(name_extension)( $(type)* $(name) );

	/** Get the $(name) property
  	  * @return The property value as a $(type) object
	  */
	$(type)* Get$(name_extension)( );
	
	/** Set the property $(name) has used */
	void SetHas$(name_extension)(bool value = true) {
		m_has$(name) = value;
	}
	
	/** Check if the object has the $(name) property set */
	bool Has$(name_extension)() const {return m_has$(name);};
	
	/** declare the property as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY( Set$(name_extension) , Get$(name_extension) , $(name) , $(type)* )
		</objectpart>
		<objectpart file="src">
void $(object)::Set$(name_extension)( $(type)* $(name) )
{
	m_$(name) = $(name);
	m_has$(name) = true;
}

$(type)* $(object)::Get$(name_extension)( )
{
	return m_$(name);
}
		</objectpart>
	</template>
	<template name="property_any_array">
		<objectpart file="header" permission="protected">	std::vector&lt;$(type)*&gt; m_$(name);
	bool m_has$(name);
</objectpart>
		<objectpart file="header" permission="public">
	
	/** Set the $(name) property
  	 * @param $(name) property value to set
  	 */
	void Set$(name_extension)( const std::vector&lt;$(type)*&gt;&amp; $(name) );

	/** Get the $(name) property
  	 * @return The property value as a $(type) object
  	 */
	std::vector&lt;$(type)*&gt; Get$(name_extension)( );
	
	/** Set the $(name) property at the given index
  	 * @param $(name) property value to set
	 * @param index index of the element to set in the array
  	 */
	void Set$(name_extension)( $(type)* $(name) , unsigned int index );
	
	/** Add the $(name) property at the end of the array
  	 * @param $(name) property value to set
  	 */
	void Add$(name_extension)( $(type)* $(name) );

	/** Get the $(name) property at the given index
	 * @param index property index to get
  	 * @return The property value as a $(type) object
  	 */
	$(type)* Get$(name_extension)( unsigned int index );
	
	/** Set the property $(name) has used */
	void SetHas$(name_extension)(bool value = true) {
		m_has$(name) = value;
	}
	
	/** Check if the object has the $(name) property set */
	bool Has$(name_extension)() const {return m_has$(name);};
	
	/** declare the property as it will be in the property table for wxExtendedObject's */
	wxgDECLARE_PROPERTY( Set$(name_extension) , Get$(name_extension) , $(name) , std::vector&lt;$(type)*&gt; )
	
		</objectpart>
		<objectpart file="src">
void $(object)::Set$(name_extension)( const std::vector&lt;$(type)*&gt;&amp; $(name) )
{
	m_$(name) = $(name);
	m_has$(name) = m_$(name).size() &gt; 0;
}

std::vector&lt;$(type)*&gt;&amp; $(object)::Get$(name_extension)( )
{
	return m_$(name);
}

void $(object)::Set$(name_extension)( $(type)* $(name) , unsigned int index )
{
	if( index >= m_$(name).size() )
		throw "error in $(object)::Set$(name) , index out of bounds";
	
	if( m_$(name)[index] != NULL )
		delete m_$(name)[index];
		
	m_$(name)[index] = $(name);
}

void $(object)::Add$(name_extension)( $(type)* $(name) )
{		
	m_$(name).push_back($(name));
}

$(type)* $(object)::Get$(name_extension)( unsigned int index )
{
	if( index >= m_$(name).size() )
		throw "error index out of bound in $(object)::Get$(name)";

	return m_$(name)[index];
}
		</objectpart>
	</template>
	<template name="child_enumerator">
		<objectpart file="header">
/* basic imports */
class $(name);

DECLARE_VARIANT_OBJECT($(name))

/** correspondance values for $(name) enumerator */
const $(type) $(name)Values [] = {
$(child_string_enum_list)
};
	
/** 
 * @class $(name)
 * @brief Class for managing enumerated types $(name)
 * @author Nicolas MACHEREY (nm@graymat.fr) http://www.rheia-framework.com
 * @date $(date)
 */
class $(name) : public wxExtendedEnumeration
{
public :

	/** constructor */
	$(name)():m_value(($(name)Flags)0){};
	
	/** copy ctor */
	$(name)(const $(name)&amp; rhs):
		m_value(rhs.m_value)
		{};
		
	/** Clone method */
	virtual wxExtendedObject* Clone() {return new $(name)(*this);};
	
	/** operator= overload */
	$(name)&amp; operator=( const $(name)&amp; rhs ){
		m_value = rhs.m_value;
		return (*this);
	}
	
	/** operator == overload */
	bool operator==( const $(name)&amp; rhs ) const{
		return (m_value==rhs.m_value);
	}
	
	/** enumerates flgas for $(name) enumerator */
	enum $(name)Flags {
	$(child_enum_list)
		// Always keep this one last in order to know the number of elements
		$(name)Num
	};	
	
	/** Get the total number of enumerated values */
	virtual unsigned int GetCount() const { return (unsigned int) $(name)Num;};
	
	/** Get enumerated as a wxArrayInt */
	virtual std::vector&lt;unsigned int&gt; GetFlags() const {
		std::vector&lt;unsigned int&gt; ret;
		for( unsigned int i = 0; i &lt; $(name)Num ; ++i )
			ret.push_back(i);
		return ret;
	};
	
	/** Get values */
	virtual const $(type)* GetValues() const {return $(name)Values;};
	
	/** Get the $(type) value assoiated to the given enumeration flag */
	const $(type)&amp; GetFromFlag( $(name)Flags value ) const {
		return $(name)Values[value];		
	}
	
	/** Get the $(type) value assoiated to the given enumeration flag */
	virtual const $(type)&amp; GetFromFlag( unsigned int value ) const {
		return $(name)Values[value];		
	}
	
	/** Get the flag associated to the given $(type) */
	$(name)Flags GetFromValue( const $(type)&amp; value ) const {
		for( unsigned int i = 0; i &lt; $(name)Num ; ++i )
			if( $(name)Values[i] == value )
				return ($(name)Flags) i;
			
			return $(name)Num;
	}
	
	/** Get the flag associated to the given $(type) */
	virtual unsigned int GetUIntFromValue( const $(type)&amp; value ) const {
		for( unsigned int i = 0; i &lt; $(name)Num ; ++i )
			if( $(name)Values[i] == value )
				return i;
			
			return (unsigned int) $(name)Num;
	}
	
	/** Get the flag */
	$(name)Flags GetFlag() const { return m_value; };
	
	/** Get the flag */
	virtual unsigned int GetUIntFlag() const { return (unsigned int) m_value; };
	
	/** Get the value from flag */
	virtual const $(type)&amp; GetValue() const {
		return GetFromFlag( m_value );
	}
	
	/** Set the value */
	void SetFlag( $(name)Flags value ) {m_value = value;};
	
	/** Set the value */
	virtual void SetFlag( unsigned int value ) {m_value = ($(name)Flags) value;};
	
	/** Set the value */
	virtual void SetValue( const $(type)&amp; value ) {
		for( unsigned int i = 0; i &lt; $(name)Num ; ++i )
			if( $(name)Values[i] == value )
				m_value = ($(name)Flags) i;
	}

private :

	$(name)Flags m_value;
		
	DECLARE_DYNAMIC_CLASS( $(object) )
	wxgDECLARE_PROPERTY_TABLE( $(object) , wxExtendedEnumeration )
};
		</objectpart>
		<objectpart file="src">
/** Implement RTTI Information forenumeration class $(name) */
IMPLEMENT_DYNAMIC_CLASS( $(name) , wxExtendedObject )
IMPLEMENT_VARIANT_OBJECT($(name))

wxgBEGIN_PROPERTY_TABLE($(name),wxT("Main class for handling $(name) enumerations") )
wxgEND_PROPERTY_TABLE()
		</objectpart>
	</template>
	<template name="typedef">
		<objectpart file="header">
/** define a new type for $(name) */
typedef $(type) $(name);
		</objectpart>
	</template>
	<template name="array_addons">
		<objectpart file="header">
	/** Add a $(real_type) object in the container
	 * @param $(name) object to add in the container
	 */
	virtual void Add$(name_extension)( const $(real_type)&amp; $(name) );
	
	/** Remove a $(real_type) object from the container at the given index
	 * @param index Index of the object to remove from the container
	 */
	virtual void Remove$(name_extension)ByIndex( unsigned int index );
	
	/** Set the $(name) property at the given index
  	 * @param $(name) property value to set
	 * @param index index of the element to set in the array
  	 */
	virtual void Set$(name_extension)At( const $(real_type)&amp; $(name) , unsigned int index );

	/** Get the $(name) property at the given index
	 * @param index property index to get
  	 * @return The property value as a $(real_type) object
  	 */
	virtual $(real_type)&amp; Get$(name_extension)At( unsigned int index );
	
	/** Find the $(real_type) object index by object
	 * @param $(name) Object to find the index for
	 * @return wxNOT_FOUND if the object wasn't found
	 */
	virtual int FindIndexBy$(name_extension)( const $(real_type)&amp; $(name) );
	
	/** Check the existance of the given $(real_type) object
	 * @param $(name) Object to check the existance for
	 * @return false if the object does not exists in the m_$(name) container
	 */
	virtual bool ExistsBy$(name_extension)( const $(real_type)&amp; $(name) );
	
	/** Get the number of $(name) elements */
	virtual unsigned int Get$(name_extension)Count() {return m_$(name).size();}
	
	/** clear the container */
	virtual void Clear$(name_extension)() {m_$(name).clear();}
		</objectpart>
		<objectpart file="src">
void $(object)::Add$(name_extension)( const $(real_type)&amp; $(name) )
{
	m_$(name).push_back($(name));
	m_has$(name) = true;
}

void $(object)::Remove$(name_extension)ByIndex( unsigned int index )
{
	if( index >= m_$(name).size() )
		WXG_THROW( wxT("Error in $(object)::Remove$(name_extension)ByIndex , index out of bounds") );
		
	std::vector&lt; $(real_type) &gt;::iterator it = m_$(name).begin() + index;
	m_$(name).erase(it);
}

void $(object)::Set$(name_extension)At( const $(real_type)&amp; $(name) , unsigned int index )
{
	if( index >= m_$(name).size() )
		WXG_THROW( wxT("Error in $(object)::Set$(name_extension)At , index out of bounds") );
	
	m_$(name)[index] = $(name);
}

$(real_type)&amp; $(object)::Get$(name_extension)At( unsigned int index )
{
	if( index >= m_$(name).size() )
		WXG_THROW( wxT("Error index out of bound in $(object)::Get$(name)At") );

	return m_$(name)[index];
}

int $(object)::FindIndexBy$(name_extension)( const $(real_type)&amp; $(name) )
{
	std::vector&lt; $(real_type) &gt;::iterator it = m_$(name).begin();
		
	for( int i = 0 ; it != m_$(name).end() ; ++it, ++i )
		if( (*it) == $(name) )
			return i;

	return wxNOT_FOUND;
}

bool $(object)::ExistsBy$(name_extension)( const $(real_type)&amp; $(name) )
{
	std::vector&lt; $(real_type) &gt;::iterator it = m_$(name).begin();
		
	for( int i = 0 ; it != m_$(name).end() ; ++it, ++i )
		if( (*it) == $(name) )
			return true;

	return false;
}
		</objectpart>
	</template>
	<template name="array_property_finder">
		<objectpart file="header">
	/** Find the $(type) object by it's $(property) attribute
	 * @param $(property) property to find the object for
	 * @return NULL if the object with the given property wasn't found
	 */
	virtual $(type)* Find$(name_extension)By$(property_extension)( const $(proprety_type)&amp; $(property) );
	
	/** Check if the property with the given name exists in the m_$(name) container
	 * @param $(property) to chekc the assocated object existance for
	 * @return false if the object with the given property wasn't found
	 */
	virtual bool $(name_extension)ExistsBy$(property_extension)( const $(property_type)&amp; $(property) );
	
	/** List all objects properties and return them in an array of string
	 * @return an array of property containing all m_$(name) $(property)
	 */
	virtual std::vector&lt; $(property_type) &gt; Get$(name_extension)$(property_extension)List();
		</objectpart>
		<objectpart file="src">
$(type)* $(object)::Find$(name_extension)By$(property_extension)( const $(proprety_type)&amp; $(property) )
{
	std::vector&lt; $(type) &gt;::iterator it = m_$(name).begin()
		
	for( int i = 0 ; it != m_$(name).end() ; ++it, ++i )
		if( (*it).Get$(property_extension)() == $(property) )
			return &amp;(*it);

	return NULL;
}

bool $(object)::$(name_extension)ExistsBy$(property_extension)( const $(proprety_type)&amp; $(property) )
{
	std::vector&lt; $(type) &gt;::iterator it = m_$(name).begin()
		
	for( int i = 0 ; it != m_$(name).end() ; ++it, ++i )
		if( (*it).Get$(property_extension)() == $(property) )
			return true;

	return false;
}

std::vector&lt; $(property_type) &gt; $(object)::Get$(name_extension)$(property_extension)List()
{
	std::vector&lt; $(property_type)&gt; ret;
	std::vector&lt; $(type) &gt;::iterator it = m_$(name).begin()
		
	for( int i = 0 ; it != m_$(name).end() ; ++it, ++i )
		ret.push_back((*it).Get$(property_extension)() );

	return ret;
}
		</objectpart>
	</template>
	<!-- 
	 Type infos are used to notify the interpreter that the related types in the xml shall be
	 translated to the one given there.
	 It will consist into a map of elements specifying the source as a key and the destination
	 as a value.
	 If a type is not found it is assumed to be complex or to be generated in the file.
	-->
	<types_info>
		<typeinfo source="positiveInteger" destination="unsigned int"/>
		<typeinfo source="variant" destination="wxExtendedObject"/>
		<typeinfo source="string" destination="wxString"/>
		<typeinfo source="boolean" destination="bool"/>
		<typeinfo source="float" destination="double"/>
		<typeinfo source="integer" destination="int"/>
		<typeinfo source="duration" destination="wxDuration"/>
		<typeinfo source="datetime" destination="wxDateTime"/>
		<typeinfo source="dateTime" destination="wxDateTime"/>
		<typeinfo source="date" destination="wxDate"/>
		<typeinfo source="time" destination="wxTime"/>
		<typeinfo source="gYear" destination="wxYear"/>
		<typeinfo source="gYearMonth" destination="wxYearMonth"/>
		<typeinfo source="gMonth" destination="wxMonth"/>
		<typeinfo source="gMonthDay" destination="wxMonthDay"/>
		<typeinfo source="ID" destination="wxString"/>
	</types_info>
	
	<!-- Add in files generated in option -->
	<addin name="wxDuration">
		<header>
/** @file wxDuration.h
 * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
 * @date Tue 18 May 2010 10:23:56 AM CEST
 */
 
#ifndef WXDURATION_H
#define WXDURATION_H

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;wx/wx.h&gt;
#include &lt;wx/log.h&gt;
#include &lt;wx/any.h&gt;
#include &lt;wx/string.h&gt;
#include &lt;set&gt;
#include &lt;string&gt;

/* imports */
class wxDuration;

DECLARE_VARIANT_OBJECT(wxDuration)

/** @class wxDuration
  * @brief Main class for handling duration nodes
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
class wxDuration : public wxObject
{	
	DECLARE_DYNAMIC_CLASS( wxDuration )
	
public :
	/** constructor */
	wxDuration() :
		m_hours(0L),
		m_minutes(0L),
		m_seconds(0L)
		{};
	
	/** basic constructor
	  * @param years number of years in the duration
	  * @param months number of months in the duration
	  * @param days number of days in the duration
	  * @param hours number of hours in the duration
	  * @param minutes number of minutes in the duration
	  * @param seconds number of seconds in the duration
	  */
	wxDuration( long years, long months , long days, long hours , long minutes, long seconds ):
		m_dateSpan( years, months , days ),
		m_hours( hours ), 
		m_minutes( minutes ), 
		m_seconds( seconds )
	{}
	
	/** assignement operator overload */
	wxDuration&amp; operator=( const wxDuration&amp; rhs )
	{
		m_dateSpan = rhs.m_dateSpan;
		m_hours = rhs.m_hours;
		m_minutes = rhs.m_minutes;
		m_seconds = rhs.m_seconds;
		
		return (*this);
	}
	
	/** equality test operator overload */
	bool operator==( const wxDuration&amp; rhs ) const
	{
		return (
			m_dateSpan == rhs.m_dateSpan &amp;&amp;
			m_hours == rhs.m_hours &amp;&amp;
			m_minutes == rhs.m_minutes &amp;&amp;
			m_seconds == rhs.m_seconds 
			);
	}
	
	/** Set the number of years */
	void SetYears( long years ) { m_dateSpan.SetYears(years); };
	
	/** Set the number of months */
	void SetMonths( long months ) { m_dateSpan.SetMonths(months); };
	
	/** Set the number of days */
	void SetDays( long days ) { m_dateSpan.SetDays(days); };
	
	/** Set the number of hours */
	void SetHours( long hours ) {m_hours = hours;}
	
	/** Set the number of minutes */
	void SetMinutes( long minutes ) {m_minutes = minutes; }
	
	/** Set the number of seconds */
	void SetSeconds( long seconds ) {m_seconds = seconds; }
	
	/** Get the number of years */
	long GetYears() const {return m_dateSpan.GetYears();};
	
	/** Get the number of months */
	long GetMonths() const {return m_dateSpan.GetMonths();};
	
	/** Get the number of days */
	long GetDays() const {return m_dateSpan.GetDays();};
	
	/** Get the number of hours */
	long GetHours() const {return m_hours;};
	
	/** Get the number of minutes */
	long GetMinutes() const {return m_minutes; };
	
	/** Get the number of seconds */
	long GetSeconds() const {return m_seconds;};
	
	/** Parse the given string in xml duration format and store it in this
	  * object
	  */
	bool FromISOString( const wxString&amp; str );
	
	/** @return the content of a wxDuration in the proper format
	  * for xml duration nodes
	  */
	wxString ToISOString() const;
	
private :

	wxDateSpan m_dateSpan;
	long m_hours;
	long m_minutes;
	long m_seconds;
};

#endif
		</header>
		<source>
/** @file wxDuration.cpp
 * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
 * @date $(date)
 */

#include "wxDuration.h"

IMPLEMENT_DYNAMIC_CLASS( wxDuration , wxObject )
IMPLEMENT_VARIANT_OBJECT(wxDuration)

bool wxDuration::FromISOString( const wxString&amp; str ) {
	wxString datePart;
	wxString timePart;

	if( str.Contains(wxT("T")) ) {
		datePart = str.BeforeFirst(wxT('T') );
		timePart = str.AfterFirst(wxT('T'));
	} else
		datePart = str;

	datePart = datePart.AfterFirst(wxT('P'));

	if( !datePart.IsEmpty() ) {
		wxString sYear;
		if( datePart.Contains(wxT("Y")))
			sYear = datePart.BeforeFirst(wxT('Y'));
		if( !sYear.IsEmpty() ) {
			datePart = datePart.AfterFirst(wxT('Y'));
			long years;
			sYear.ToLong( &amp;years );
			SetYears( years );
		} else
			SetYears(0L);

		wxString sMonth;

		if( datePart.Contains(wxT("M")))
			sMonth = datePart.BeforeFirst(wxT('M'));

		if( !sMonth.IsEmpty() ) {
			datePart = datePart.AfterFirst(wxT('M'));
			long months;
			sMonth.ToLong( &amp;months );
			SetMonths( months );
		} else
			SetMonths(0L);

		wxString sDay;
		if( datePart.Contains(wxT("D")))
			sDay = datePart.BeforeFirst(wxT('D'));

		if( !sDay.IsEmpty() ) {
			datePart = datePart.AfterFirst(wxT('D'));
			long days;
			sDay.ToLong( &amp;days );
			SetDays( days );
		} else
			SetDays(0L);
	}
	if( !timePart.IsEmpty() ) {

		wxString sHours;

		if( timePart.Contains(wxT("H")))
			sHours = timePart.BeforeFirst(wxT('H'));

		if( !sHours.IsEmpty() ) {
			timePart = timePart.AfterFirst(wxT('H'));
			long hours;
			sHours.ToLong( &amp;hours );
			SetHours( hours );
		} else
			SetHours(0L);

		wxString sMinutes ;

		if( timePart.Contains(wxT("M")))
			sMinutes = timePart.BeforeFirst(wxT('M'));

		if( !sMinutes.IsEmpty() ) {
			timePart = timePart.AfterFirst(wxT('M'));
			long minutes;
			sMinutes.ToLong( &amp;minutes );
			SetMinutes( minutes );
		} else
			SetMinutes(0L);

		wxString sSeconds;

		if( timePart.Contains(wxT("S")) )
			sSeconds = timePart.BeforeFirst(wxT('S'));

		if( !sSeconds.IsEmpty() ) {
			timePart = timePart.AfterFirst(wxT('S'));
			long seconds;
			sSeconds.ToLong( &amp;seconds );
			SetSeconds( seconds );
		} else
			SetSeconds(0L);
	}
	return true;
}

wxString wxDuration::ToISOString() const {
	wxString ret = wxString::Format( wxT("P%dY%dM%dDT%dH%dM%dS") ,
	                                 m_dateSpan.GetYears(),
	                                 m_dateSpan.GetMonths(),
	                                 m_dateSpan.GetDays(),
	                                 m_hours,
	                                 m_minutes,
	                                 m_seconds);

	return ret;
}
		</source>
	</addin>
	<addin name="wxgException">
		<header>
/**
*   @file wxgException.h
*   @brief wxgException is the basic class for wxg's error handling unit.
*
*   Two macros are defined to help error handling in wxg:
*   WXG_THROW() and WXG_ASSERT().
*
*   @note WXG_ASSERT() does nothing in release mode. For debug mode, compile with -D__WXDEBUG__
*
*	@author Nicolas Macherey (nm@graymat.fr)
*	@version 0.0.1
*	@date 03-Jan-2009
*/
#ifndef wxgException_h_
#define wxgException_h_

/**
*	@class wxgException
*	@brief The base wxg exception object.
*
*	In the wxg FrameWork you can manage errors handled by the different elements and objects by using the wxgExcpetion object.
*	All errors and exeptions must use as base exception class wxgException.
*
*	@author Nicolas Macherey (nm@graymat.fr)
*	@version 0.0.1
*	@date 03-Jan-2009
*/
class wxgException
{
public:
    wxgException(const wxString&amp; msg, const wxString&amp; file, int line);
    virtual ~wxgException();

    /**
    *   @brief Display exception error message.
    *   @param safe If true, wxSafeShowMessage will be used to display the error,
    *             else a normal message box will be used.
    */
    void ShowErrorMessage(bool safe = true);
	
	wxString GetErrorMessage();

    // public members
    wxString Message; ///&lt; The exception's error message.
    wxString File; ///&lt; The file where the exception was raised.
    int Line; ///&lt; The line in the file where the exception was raised.
};

#if wxUSE_UNICODE
#define WXG_THROW(message) throw wxgException(message, wxC2U(__FILE__), __LINE__)
#else
#define WXG_THROW(message) throw wxgException(message, __FILE__, __LINE__)
#endif

#ifndef __WXDEBUG__
#define WXG_ASSERT(expr)
#else
// In unix we use kill to terminate the application, that makes gdb
// keep it alive which makes debugging easier.
// (thanks go to an unknown author)
#ifdef __WXMSW__
#define DIE() exit(1)
#else
#include &lt;csignal&gt;
#define DIE() kill(0, SIGTERM)
#endif

#if wxUSE_UNICODE
#define WXG_ASSERT_MESSAGE(expr) \
            wxString err; \
            err.Printf(_T("Assertion failed in %s at %s:%d.\n\n%s"), wxC2U(__PRETTY_FUNCTION__).c_str(), wxC2U(__FILE__).c_str(), __LINE__, wxC2U(#expr).c_str());
#else
#define WXG_ASSERT_MESSAGE(expr) \
            wxString err; \
            err.Printf(_T("Assertion failed in %s at %s:%d.\n\n%s"), __PRETTY_FUNCTION__, __FILE__, __LINE__, #expr);
#endif

// non-fatal assertion
#define WXG_ASSERT_NONFATAL(expr) \
        if (!(expr)) \
        { \
            WXG_ASSERT_MESSAGE(expr); \
            wxSafeShowMessage(_T("Assertion error"), err); \
        }

// fatal assertion
#define WXG_ASSERT(expr) \
        if (!(expr)) \
        { \
            WXG_ASSERT_MESSAGE(expr); \
            wxSafeShowMessage(_T("Fatal assertion error"), err); \
            DIE(); \
        }
#endif

#endif
		</header>
		<source>
/**
*   @file wxgException.cpp
*   @brief wxgExecption is the basic class for wxg's error handling unit.
*
*   Two macros are defined to help error handling in wxg:
*   WXG_THROW() and WXG_ASSERT().
*
*   @note WXG_ASSERT() does nothing in release mode. For debug mode, compile with -D__WXDEBUG__
*
*	@author Nicolas Macherey (nm@graymat.fr)
*	@version 0.0.1
*	@date 03-Jan-2009
*/
#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include &lt;iostream&gt;
#include &lt;map&gt;

#include &lt;wx/msgdlg.h&gt;
#include &lt;wx/log.h&gt; // for wxSafeShowMessage()
#include &lt;wx/intl.h&gt;

#include "wxgDefines.h"
#include "wxgException.h"

wxgException::wxgException(const wxString&amp; msg, const wxString&amp; file, int line)
  : Message(msg),
    File(file),
    Line(line)
{}

wxgException::~wxgException()
{}


void wxgException::ShowErrorMessage(bool safe)
{
    wxString gccvers;
#ifdef __GNUC__
    gccvers.Printf(_T("gcc %d.%d.%d"), __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
#endif

    wxString title = _("Exception");
    wxString err;
    err.Printf(_("An exception has been raised!\n\n"
                 "The application encountered an error at %s, on line %d.\n"
                 "The error message is:\n\n%s\n\n"
                 "wxg Version revision %d (%s, "
                 "build: %s %s)"),
               File.c_str(), Line, Message.c_str(),
               1123, gccvers.c_str(),
               wxT(__DATE__), wxT(__TIME__));

	if( safe )
		std::cerr &lt;&lt;  wxcU2C( title )  &lt;&lt; " : " &lt;&lt; wxcU2C( err ) &lt;&lt; std::endl;
	else
		wxMessageBox( err , wxT("wxg exception catched !") , wxICON_ERROR );
}

wxString wxgException::GetErrorMessage()
{
	wxString gccvers;
#ifdef __GNUC__
    gccvers.Printf(_T("gcc %d.%d.%d"), __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
#endif

    wxString title = _("Exception");
    wxString err;
    err.Printf(_("An exception has been raised!\n\n"
                 "The application encountered an error at %s, on line %d.\n"
                 "The error message is:\n\n%s\n\n"
                 "wxg Version revision %d (%s, "
                 "build: %s %s)"),
               File.c_str(), Line, Message.c_str(),
               1123, gccvers.c_str(),
               wxT(__DATE__), wxT(__TIME__));
			   
	return err;
}		
		</source>
	</addin>
	<addin name="wxExtendedObject">
		<header>

/** define a map of strings */
typedef std::map&lt; wxString , wxString &gt; wxgStringStringMap;

const wxString emptStr = wxEmptyString;

/** @class wxExtendedObject
 * wxExtended Objects are objects able to provide the application
 * with their type info. 
 * Hence attributes and properties can be accessed generically in the
 * application.
 */
class wxExtendedObject : public wxObject
{
	DECLARE_ABSTRACT_CLASS( wxExtendedObject )

public :
	
	/** constructor */
	wxExtendedObject() {};
	
	/** Clone method */
	virtual wxExtendedObject* Clone() = 0;
	
	/*********************************************************************
	 * METHODS THAT ANY DERIVED OBJECTS SHALL OVERLOAD USING THE
	 * MACRO SYSTEM PROVIDED HERE
	 * ******************************************************************/
	
	/** Set the attribute contained in name at the given value */
	virtual void SetAttribute( const wxString&amp; WXUNUSED(name) , wxAny&amp; WXUNUSED(value) ) {};
	
	/** Get the attribute contained in name */
	virtual wxAny GetAttribute( const wxString&amp; WXUNUSED(name) ) {wxAny ret;return ret;};
	
	/** Get the attribute helper */
	virtual const wxString&amp; GetAttributeHelper( const wxString&amp; WXUNUSED(name) ) {return emptStr;};
	
	/** Set the attribute helper */
	virtual const wxString&amp; GetAttributeType( const wxString&amp; WXUNUSED(name) ) {return emptStr;};
	
	/** Get the attribute list map */
	virtual wxgStringStringMap GetAttributeList() {wxgStringStringMap empty;return empty;};
	
	/** Get the attribute helper list map */
	virtual wxgStringStringMap GetAttributeHelpers() {wxgStringStringMap empty;return empty;};
	
	/** enumerates attribute types */
	enum wxPropertyType // Quite same as wx defined in XTI
	{
		wxT_VOID = 0, // unknown type
		wxT_BOOL,
		wxT_CHAR,
		wxT_UCHAR,
		wxT_INT,
		wxT_UINT,
		wxT_LONG,
		wxT_ULONG,
		wxT_FLOAT,
		wxT_DOUBLE,
		wxT_STRING, // must be wxString
		wxT_CUSTOM, // user defined type (e.g. wxPoint)

		wxT_LAST_TYPE_KIND = wxT_CUSTOM // sentinel for bad data, asserts, debugging
	};
	
	/** Get the type of the give attribute at the given index */
	virtual wxPropertyType GetType( const wxString&amp; WXUNUSED(name) ) {return wxT_VOID;};
};

/** @class wxGrammarFunctorBase
  * @brief Base abstract class for defining a functor pattern
  * A functor is a generalization of a pointer which allows to call
  * non static methods of instanciated objects. This class implements
  * this pattern.
  */
class wxGrammarFunctorBase
{
public:
    /** Constructor */
    virtual ~wxGrammarFunctorBase() {}

    /** Any functor shall provide with a method to set and get its property as a variant
      */
    virtual void SetAttribute( void* This , wxAny&amp; variant ) = 0;
    virtual wxAny GetAttribute( void* This ) = 0;
};

/** @class wxGrammarFunctor
  * @brief Generalization of a functor as a template
  * Using this template you will be able to associate an object type to a functor
  * So the registered Setters and Getters can be called for any instance of the 
  * object generically.
  */
template&lt;class ClassType&gt; class wxGrammarFunctor : public wxGrammarFunctorBase
{
private:
	/** Define a pointer to the callback method */
	typedef void (ClassType::*Setter)(wxAny&amp;);
	typedef wxAny (ClassType::*Getter)();

	Setter setter;
	Getter getter;

public:

	/** Default ctor */
	wxGrammarFunctor() : setter(0), getter(0) {};
	/** Basic constructor */
	wxGrammarFunctor( Setter setter_, Getter getter_ ) : setter(setter_), getter(getter_) {}

	/** Copy constructor */
	wxGrammarFunctor(const wxGrammarFunctor&lt;ClassType&gt;&amp; rhs) : setter(rhs.setter), getter(rhs.getter) {}

	virtual void SetAttribute( void* This , wxAny&amp; variant )
	{
		ClassType* castThis = (ClassType*) This;
		(castThis-&gt;*setter)(variant);
	}

	virtual wxAny GetAttribute( void* This )
	{
		ClassType* castThis = (ClassType*) This;
		return (castThis-&gt;*getter)();
	}

};

/** @class wxGrammarAccessorRegistrant
  * @brief Helper class for registering functors at startup for an object
  * This class can be instanciated globally at startup for each attribute you need
  * to register in real time.
  * @note that you shall have call the 2 following macros before using this template :
  * DECLARE_OBJECT_FUNCTOR_MAP and DECLARE_ATTRIBUTE_MAP
  */
template&lt;class T&gt; class wxGrammarAccessorRegistrant
{
	/** Define a pointer to the callback method */
    	typedef void (T::*Setter)(wxAny&amp;);
    	typedef wxAny (T::*Getter)();

public :
	wxGrammarAccessorRegistrant( const wxString&amp; name , Setter setter , Getter getter , const wxString&amp; type , const wxString&amp; help )
	{
		wxGrammarFunctor&lt;T&gt; functor( setter , getter );
		T::s_attributes[name] = type;
		T::s_attributeHelpers[name] = help;
		T::s_accessors[name] = functor;
	}
};

/** define a map of wxGrammarFunctorBase in order to register each setter and getters */
typedef std::map&lt; wxString , wxGrammarFunctorBase* &gt; wxGrammarFunctorBaseMap;

/** Call this before your object declaration */
#define wxgDECLARE_OBJECT_FUNCTOR_MAP( object ) \
	typedef std::map&lt; wxString , wxGrammarFunctor&lt;object&gt; &gt; wxGrammarFunctorMap; \
	typedef std::map&lt; wxString , wxGrammarFunctor&lt;object&gt; &gt;::iterator wxGrammarFunctorMapIterator;

/* Macros definitions for registering objects properties and enable setting them as variant data */
/** Call this at the early stage of your object declaration */
#define wxgDECLARE_PROPERTY_TABLE( object , base )\
	friend class wxGrammarAccessorRegistrant&lt;object&gt;;\
	public :\
		wxgDECLARE_OBJECT_FUNCTOR_MAP( object )\
	private :\
		static wxgStringStringMap s_attributes;\
		static wxgStringStringMap s_attributeHelpers;\
		static wxGrammarFunctorMap s_accessors;\
	public :\
		static wxgStringStringMap GetAttributeList(object* /*instance*/) {return s_attributes;};\
		static wxgStringStringMap GetAttributeHelpers(object* /*instance*/) {return s_attributeHelpers;};\
		virtual wxgStringStringMap GetAttributeList() {return GetAttributeList(this);}; \
		virtual wxgStringStringMap GetAttributeHelpers() {return GetAttributeHelpers(this);};\
		static void SetAttribute( object* instance , const wxString&amp; name , wxAny&amp; value )\
		{\
			wxgStringStringMap::iterator it = s_attributes.find(name);\
			if(it!=s_attributes.end()){\
				wxGrammarFunctorMapIterator fit = s_accessors.find(name);\
				if(fit==s_accessors.end())\
					WXG_THROW(wxT("Error property setter not found"));\
				fit-&gt;second.SetAttribute( instance , value );\
			}\
			else {\
				wxString baseName = wxT(#base);\
				if(baseName.Contains(wxT("wxExtended")))\
					WXG_THROW(wxT("Error property not found"));\
				 instance-&gt;base::SetAttribute(name,value);\
			}\
		}\
		static wxAny GetAttribute( object* instance , const wxString&amp; name )\
		{\
			wxgStringStringMap::iterator it=s_attributes.find(name);\
			if(it!=s_attributes.end()) {\
				wxGrammarFunctorMapIterator fit = s_accessors.find(name);\
				if(fit==s_accessors.end())\
					WXG_THROW(wxT("Error property setter not found"));\
				return fit-&gt;second.GetAttribute(instance);\
			}\
			else {\
				wxString baseName=wxT(#base);\
				if(baseName.Contains(wxT("wxExtended")))\
					WXG_THROW(wxT("Error property not found"));\
				return instance-&gt;base::GetAttribute(name);\
			}\
		};\
		virtual void SetAttribute( const wxString&amp; name , wxAny&amp; value )\
		{\
			SetAttribute(this,name,value);\
		}\
		virtual wxAny GetAttribute( const wxString&amp; name )\
		{\
			return GetAttribute(this,name);\
		}\
		static const wxString&amp; GetAttributeHelper( object* instance , const wxString&amp; name )\
		{\
			wxgStringStringMap::iterator it = s_attributeHelpers.find( name );\
			if(it!=s_attributeHelpers.end())\
				return it-&gt;second;\
			wxString baseName = wxT(#base);\
			if(baseName.Contains( wxT("wxExtended")))\
				WXG_THROW(wxT("Error property not found"));\
			return  instance-&gt;base::GetAttributeHelper(name);\
		}\
		static const wxString&amp; GetAttributeType( object* instance , const wxString&amp; name )\
		{\
			wxgStringStringMap::iterator it = s_attributes.find(name);\
			if( it != s_attributes.end() )\
				return it-&gt;second;\
			wxString baseName = wxT(#base);\
			if( baseName.Contains(wxT("wxExtended")))\
				WXG_THROW(wxT("Error property not found")); \
			return  instance-&gt;base::GetAttributeType(name);\
		}\
		static wxExtendedObject::wxPropertyType GetType( object* instance , const wxString&amp; name )\
		{\
			wxgStringStringMap::iterator it = s_attributes.find(name);\
			if(it!=s_attributes.end()){\
				wxString type = it-&gt;second;\
				if( type.IsSameAs(wxT("bool")) )\
					return wxExtendedObject::wxT_BOOL;\
				else if (type.IsSameAs(wxT("void")) )\
					return wxExtendedObject::wxT_VOID;\
				else if (type.IsSameAs(wxT("char")) )\
					return wxExtendedObject::wxT_CHAR;\
				else if( type.IsSameAs(wxT("uchar")) )\
					return wxExtendedObject::wxT_UCHAR;\
				else if( type.IsSameAs(wxT("int")) )\
					return wxExtendedObject::wxT_INT;\
				else if( type.IsSameAs(wxT("uint")) )\
					return wxExtendedObject::wxT_UINT;\
				else if( type.IsSameAs(wxT("long")) )\
					return wxExtendedObject::wxT_LONG;\
				else if( type.IsSameAs(wxT("ulong")))\
					return wxExtendedObject::wxT_ULONG;\
				else if( type.IsSameAs(wxT("float")) )\
					return wxExtendedObject::wxT_FLOAT;\
				else if( type.IsSameAs(wxT("double")) )\
					return wxExtendedObject::wxT_DOUBLE;\
				else if( type.IsSameAs(wxT("string"))||type.IsSameAs(wxT("wxString")) )\
					return wxExtendedObject::wxT_STRING;\
				else \
					return wxExtendedObject::wxT_CUSTOM;\
			}\
			else{\
				wxString baseName = wxT(#base);\
				if( baseName.Contains(wxT("wxExtended")))\
					WXG_THROW( wxT("Error property not found"));\
				return  instance-&gt;base::GetType( name );\
			}\
		}\
		virtual const wxString&amp; GetAttributeHelper( const wxString&amp; name )\
		{\
			return GetAttributeHelper(this,name);\
		}\
		virtual const wxString&amp; GetAttributeType( const wxString&amp; name )\
		{\
			return GetAttributeType(this,name);\
		}\
		virtual wxExtendedObject::wxPropertyType GetType( const wxString&amp; name )\
		{\
			return GetType( this , name );\
		}


/** call this in your source file */
#define wxgIMPLEMENT_PROPERTY_TABLE( object ) \
	namespace ns##object { \
		wxgStringStringMap dummymap; \
		object::wxGrammarFunctorMap fdmap; \
	};\
	wxgStringStringMap object::s_attributes = ns##object::dummymap; \
	wxgStringStringMap object::s_attributeHelpers = ns##object::dummymap; \
	object::wxGrammarFunctorMap object::s_accessors = ns##object::fdmap;

/** Call this for any attribute you need to register, 
  * @note that attributes are supposed to be declared in the class
  * using the m_ standard.
  */
#define wxgIMPLEMENT_PROPERTY( setter , getter , name , type )\
	public : \
		void setter##Variant( wxAny&amp; value ) \
		{\
			wxString vtype = wxT(#type);\
			if( !value.CheckType&lt;type&gt;() )\
				WXG_THROW( wxT("Error wrong property class") );\
			m_##name = value.As&lt;type&gt;();\
			m_has##name = true;\
		}\
		wxAny getter##Variant()\
		{\
			wxAny ret;\
			ret = &amp;m_##name;\
			return ret; \
		}\
		void setter(const type&amp; name) {m_##name = name;};\
		type&amp; getter() const {return m_##name;};\
	private : \
		type m_##name;\
		bool m_has#name;
		
/** This is an example of what you can use if you do not want
 * to define all your stuff in this macro.
 * You code will be more readable :D
 */
#define wxgDECLARE_PROPERTY( setter , getter , name , type )\
	public : \
		void setter##Variant( wxAny&amp; value ) \
		{\
			wxString vtype = wxT(#type);\
			if( !value.CheckType&lt;type&gt;() )\
				WXG_THROW( wxT("Error wrong property class") );\
			m_##name = value.As&lt;type&gt;();\
			m_has##name = true;\
		}\
		wxAny getter##Variant()\
		{\
			wxAny ret;\
			ret = &amp;m_##name;\
			return ret; \
		}
		
/** This is an example of what you can use if you do not want
 * to define all your stuff in this macro.
 * You code will be more readable :D
 */
#define wxgDECLARE_PROPERTY_CHECKER( setter , getter , name , type )\
	public : \
		void setter##Variant( wxAny&amp; value ) \
		{\
			wxString vtype = wxT(#type);\
			if( !value.CheckType&lt;type&gt;() )\
				WXG_THROW( wxT("Error wrong property class") );\
			m_##name = value.As&lt;type&gt;();\
		}\
		wxAny getter##Variant()\
		{\
			wxAny ret;\
			ret = &amp;m_##name;\
			return ret; \
		}
		
#define wxgBEGIN_PROPERTY_TABLE(object , description ) \
	wxgIMPLEMENT_PROPERTY_TABLE( object ) \
	wxgREGISTER_OBJECT( object , description  ) \
	namespace ns##object { \
		typedef object class_t;
		
#define wxgEND_PROPERTY_TABLE() \
	};
		
/** Call this in your cpp file */
#define wxgPROPERTY( setter , getter , name , type , help ) \
		wxGrammarAccessorRegistrant&lt;class_t&gt; accessorRegistrant##name( wxT(#name) , &amp;class_t::setter##Variant , &amp;class_t::getter##Variant , wxT(#type) , help );

$(extended_enumeration_hdr)

#endif
		</header>
		<source>
/**
 * @file wxExtendedObject.cpp 
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;wx/wx.h>

#include "wxExtendedObject.h"

IMPLEMENT_ABSTRACT_CLASS( wxExtendedObject , wxObject )

$(extended_enumeration_src)
		</source>
	</addin>
	<addin name="wxExtendedObjectFactory">
		<header>
/**
 * @file wxExtendedObjectFactory.h
 * @brief main file for managing extended objects, 
 * registering them and accessing their information
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#ifndef WXEXTENDEDOBJECTFACTORY_H
#define WXEXTENDEDOBJECTFACTORY_H

#include "wxgSingleton.h"

/* imports */
class wxExtendedObject;
class wxExtendedObjectFactory;

/** define Generator constructor methods for building generically any kind of generators */
typedef wxExtendedObject* (*wxExtendedObjectConstructor)();

/** define Generator destructor methods for freeing any created generator */
typedef void (*wxExtendedObjectDestructor)(wxExtendedObject*);



/** @struct wxExtendedObjectRegistration
  * @brief main strcuture for storing registration information about the
  * construction and destrcution of a wxExtendedObject.
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
struct wxExtendedObjectRegistration
{
	/****************************************************************
	  * STRUCTURE ACCESSORS
	  **************************************************************/
	/** default constructor */
	wxExtendedObjectRegistration( ) : 
		ctor(0),dtor(0)
	{};

	/** copy constructor */
	wxExtendedObjectRegistration( const wxExtendedObjectRegistration&amp; rhs ):
		name(rhs.name),
		description(rhs.description),
		ctor(rhs.ctor),
		dtor(rhs.dtor)
	{};

	/** operator= overload */
	wxExtendedObjectRegistration&amp; operator=(const wxExtendedObjectRegistration&amp; rhs)
	{
		name = rhs.name;
		description = rhs.description;
		ctor = rhs.ctor;
		dtor = rhs.dtor;
		return (*this);
	}


	/****************************************************************
	  * PROPERTIES
	  **************************************************************/
	wxString name;
	wxString description;
	wxExtendedObjectConstructor ctor;
	wxExtendedObjectDestructor dtor;
};

/** now we just have to define a map of wxExtendedObjectRegistration in order to manage them in
  * the wxExtendedObjectFactory.
  */
typedef std::map&lt; wxString , wxExtendedObjectRegistration &gt; wxExtendedObjectRegistrationMap;

/** @class wxExtendedObjectFactory
  * @brief Main class for handling all available generator in wxGrammar
  *
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
class wxExtendedObjectFactory : public wxgSingleton&lt;wxExtendedObjectFactory&gt;
{
	friend class wxgSingleton&lt;wxExtendedObjectFactory&gt;;

public :
	/*******************************************************************************
    	*   ACCESSORS
    	*******************************************************************************/

    	/** Get the list of registered objects in this manager
    	  * This will provide you with an array string of registered object names
    	  * but not with their description, if you need to get the list of objects
	  * descriptions you should call wxExtendedObjectFactory::GetDescriptions.Please
	  * note that this list might change at run time as this factory is made
	  * for adding and removing objects dynamically.
    	  */
	wxArrayString GetList();

	/** Get all descriptions associated to each registered object. Please
	  * note that this list might change at run time as this factory is made
	  * for adding and removing objects dynamically.
	  */
	wxArrayString GetDescriptions();

	/** Register an object in the factory.
	  * Each object can only be registered once.
	  * Please see the wxExtendedObjectRegistrant object in order
	  * to know how to register a new object in this factory.
	  * @param name object name
	  * @param description object's description
	  * @param ctor object constructor function pointer
	  * @param dtor object destructor function pointer
	  * @return false if the object already exists in this factory !
	  */
	bool RegisterObject( const wxString&amp; name,
			const wxString&amp; description,
			wxExtendedObjectConstructor ctor,
			wxExtendedObjectDestructor dtor );

	/** Unregister object from that factory,
	  * Once you have call this method the object will not be available
	  * in this factory.
	  */
	bool UnregisterObject( const wxString&amp; name );

	/** Creates an object accordingly to it's name
	  * You can call this method at any time if you want to create an object
	  * from it's name only.
	  * @param name object's name
	  * @return the requested object instance if exists NULL if it is not existing
	  */
	wxExtendedObject* CreateObject( const wxString&amp; name );

	/** Check the existence of an object by it's name
	  * @param name object name to check the existance for
	  * @return false if the object is not registered in the factory
	  */
	bool Exists( const wxString&amp; name );
	
	/** Find the description associated to the object name
	  * @param name object's name to find the description for
	  * @return a wxEmptyString if the object does not exists in the factory
	  */
	wxString GetDescription( const wxString&amp; name );

private :
	/***********************************************************************************
	  * CONSTRUCTOR AND DESTRUCTOR
	  *********************************************************************************/
	/** Default constructor,
	  * You cannot build directly this class, this class is a global singleton 
	  * you have to use wxExtendedObjectFactory::Get() to access the global instance 
	  * of this class.
	  */
	wxExtendedObjectFactory();

	/** Default destructor
	  * You shall never have to destroy this class by your own unless you are an
	  * application developper. Anyway if you want to free the global instance of this manager
	  * properly, you have to call wxExtendedObjectFactory::Free() to free it's global instance
	  */
	~wxExtendedObjectFactory();

	/** container of all registered objects */
	wxExtendedObjectRegistrationMap m_objects;
};

/**
  * @class wxExtendedObjectRegistrant
  * @brief this main template allows you to register easily your wxExtendedObject in the wxExtendedObjectFactory
  * 
  * Assuming that your object has the following name : MyObject , an example could be :
  * @code 
  *	namespace {
  *		wxGrammargeneratorRegistrant&lt;MyObject&gt; registrant( wxT("MyObject") , wxT("Description of my object");
  *	};
  * @endcode
  * This shall be done in the top of MyObject.cpp file.
  * I also wrote a helper in order to write it faster :
  * @code
  * wxgREGISTER_OBJECT( MyObject , wxtT("Description of my object") );
  * @endcode
  *
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
template&lt;class T&gt; class wxExtendedObjectRegistrant
{

public :
	wxExtendedObjectRegistrant( const wxString&amp; name , const wxString&amp; description ):
		m_name(name)
	{
		/* The main task is to call the wxGrammargeneratorFactory and to register the object in 
		 * using our two satic method that will be used to register in the factory */
		wxExtendedObjectFactory::Get()-&gt;RegisterObject( name , description , &amp;Create , &amp;Free );
	}
	
	~wxExtendedObjectRegistrant()
	{
		/* if the factory is down this means that the instance has already been removed from it */
		if(!wxExtendedObjectFactory::IsDown()) 
			wxExtendedObjectFactory::Get()-&gt;UnregisterObject( m_name );
	};
	
	/** The create method is made static, so that the program knows the adress of that method without the
	  * need of making a functor or something complicated.
	  * this method will correspond to the wxExtendedObjectConstructor pointer 
	  */
	static wxExtendedObject* Create( )
	{
		return new T( );
	}

	/** The free method is made static so that the program knows its adress. It corresponds to the 
	  * wxExtendedObjectDestructor function pointer
	  */
	static void Free( wxExtendedObject* object )
	{
		delete object;
	}

private :
	wxString m_name;
};

#define wxgREGISTER_OBJECT( object , description ) \
	namespace ns##object { \
		wxExtendedObjectRegistrant&lt;object&gt; registrant( wxT(#object) , description ); \
	};

#endif		
		</header>
		<source>
/**
 * @file wxExtendedObjectFactory.h
 * @brief main file for managing extended objects
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;wx/wx.h&gt;
#include &lt;wx/log.h&gt;
#include &lt;wx/variant.h&gt;
#include &lt;wx/regex.h&gt;
#include &lt;wx/datetime.h&gt;
#include &lt;wx/ffile.h&gt;
#include &lt;wx/filesys.h&gt;
#include &lt;wx/filefn.h&gt;

#include "wxgSingleton.h"
#include "wxExtendedObject.h"
#include "wxExtendedObjectFactory.h"

/** Global instance for the wxExtendedObjectFactory */
template&lt;&gt; wxExtendedObjectFactory* wxgSingleton&lt;wxExtendedObjectFactory&gt;::instance = 0;

/** Global isShutdown initialization for the wxExtendedObjectFactory */
template&lt;&gt; bool  wxgSingleton&lt;wxExtendedObjectFactory&gt;::isShutdown = false;

wxExtendedObjectFactory::wxExtendedObjectFactory()
{

}

wxExtendedObjectFactory::~wxExtendedObjectFactory()
{
	m_objects.clear();
}

wxArrayString wxExtendedObjectFactory::GetList()
{
	wxArrayString ret;

	wxExtendedObjectRegistrationMap::iterator it = m_objects.begin();
	for( ; it != m_objects.end() ; ++it )
		ret.Add(it-&gt;first);

	return ret;
}

wxArrayString wxExtendedObjectFactory::GetDescriptions()
{
	wxArrayString ret;

	wxExtendedObjectRegistrationMap::iterator it = m_objects.begin();
	for( ; it != m_objects.end() ; ++it )
		ret.Add(it-&gt;second.description);

	return ret;
}

bool wxExtendedObjectFactory::RegisterObject( const wxString&amp; name,
		const wxString&amp; description,
		wxExtendedObjectConstructor ctor,
		wxExtendedObjectDestructor dtor )
{
	wxExtendedObjectRegistrationMap::iterator it = m_objects.find(name);

	if( it != m_objects.end() )
		return false;

	wxExtendedObjectRegistration info;
	info.name = name;
	info.description = description;
	info.ctor = ctor;
	info.dtor = dtor;

	m_objects[name] = info;

	return true;
}

bool wxExtendedObjectFactory::UnregisterObject( const wxString&amp; name )
{
	wxExtendedObjectRegistrationMap::iterator it = m_objects.find(name);

	if( it == m_objects.end() )
		return false;

	m_objects.erase(it);
	return true;
}

wxExtendedObject* wxExtendedObjectFactory::CreateObject( const wxString&amp; name )
{
	wxExtendedObjectRegistrationMap::iterator it = m_objects.find(name);

	if( it == m_objects.end() )
		return NULL;

	wxExtendedObject* object = it-&gt;second.ctor( );
	return object;
}

bool wxExtendedObjectFactory::Exists( const wxString&amp; name )
{
	wxExtendedObjectRegistrationMap::iterator it = m_objects.find(name);

	if( it == m_objects.end() )
		return false;

	return true;
}

wxString wxExtendedObjectFactory::GetDescription( const wxString&amp; name )
{
	wxExtendedObjectRegistrationMap::iterator it = m_objects.find(name);

	if( it == m_objects.end() )
		return wxEmptyString;

	return it-&gt;second.description;
}			
		</source>
	</addin>
	<addin name="wxgSingleton">
		<header>
/**
 * @file wxgSingleton.h
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#ifndef WXG_SINGLETON_H
#define WXG_SINGLETON_H

/* @class wxgSingleton
 *
 * @brief wxgSingleton is the class used for simulating static manager.
 *
 * To use this class simply inherit your object from wxgSingleton&lt;YourModule&gt; and instanciate
 * instance and isShutdown static variables for the wxgSingleton&lt;YourModule&gt; then you will
 * have access to your object global instance.
 * YourModule::Get().
 *
 * @note this class has been taken from the Code::Blocks IDE
 *
 * @author Nicolas Macherey ( nm@graymat.fr )
 * @date 02-Dec-2008
 * @version 0.0.1
 */
template &lt;class MgrT&gt; class wxgSingleton
{
    static MgrT *instance;										/*!&lt; global instance for the module */
    static bool isShutdown;										/*!&lt; is the module shutting down */

    explicit wxgSingleton(const wxgSingleton&lt;MgrT&gt;&amp;){};							/*!&lt; copy constructor */
    wxgSingleton&lt;MgrT&gt;&amp; operator=(wxgSingleton&lt;MgrT&gt; const&amp;){return *this;};		/*!&lt; operator = overload */

protected:

    wxgSingleton(){assert(wxgSingleton&lt;MgrT&gt;::instance == 0);}					/*!&lt; Default constructor */
    virtual ~wxgSingleton(){wxgSingleton&lt;MgrT&gt;::instance = 0;}					/*!&lt; Default destructor */

public:

	/*! Specifies is the manager is valid or not */
	static inline bool Valid(){return (instance!=0) ? true : false;}

	/*! Use this function to have access to the managers global instance */
    static inline MgrT* Get()
    {
        if(instance == 0 &amp;&amp; isShutdown == false)
            instance = new MgrT();

        return instance;
    }

	/*! NEVER call this function, it called by the application when closing */
    static void Free()
    {
        isShutdown = true;
        delete instance;
        instance = 0;
    }

    static inline bool IsDown() {return isShutdown;};
};

#endif
		</header>
	</addin>
	<addin name="wxgDefines">
		<header>
/**
 * @file wxgDefines.h
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#ifndef WXG_DEFINES_H
#define WXG_DEFINES_H

#include &lt;wx/string.h&gt;
#include &lt;set&gt;
#include &lt;string&gt;

/// Return @c str as a proper unicode-compatible string
inline wxString wxC2U(const char* str)
{
#if wxUSE_UNICODE
    return wxString(str, wxConvUTF8);
#else
    return wxString(str);
#endif
}

/// Return @c str as a proper unicode-compatible string
inline std::string wxU2C(const wxString&amp; str)
{
    std::string sstr;

#if wxUSE_UNICODE
    sstr = (const char*) str.mb_str(wxConvUTF8);
#else
    sstr = (const char*) str.mb_str();
#endif

    return sstr;
}

#define wxxU2C( str ) reinterpret_cast&lt;const xmlChar*&gt;( wxU2C( str ).c_str() )
#define wxcU2C( str ) wxU2C( str ).c_str()

/** Get the attribute content in the given node
  * @param node node to get the named attribute in
  * @param name attribute name to get
  * @return a wxEmptyString if the attribute does not exists
  */
inline wxString GetXmlAttr( xmlNode* node , const wxString&amp; name )
{
	xmlChar* attr = xmlGetProp( node , wxxU2C(name) );

	if( attr == NULL )
		return wxEmptyString;

	wxString ret = wxC2U( (char*) attr );
	xmlFree(attr);

	return ret;
}

/** Get the content of the node as a wxString 
  * @param node node to get the content for
  */
inline wxString GetXmlContent( xmlNode* node )
{
	xmlChar* content = xmlNodeGetContent( node );

	if( content == NULL )
		return wxEmptyString;

	wxString ret = wxC2U( (char*) content );
	xmlFree(content);

	return ret;
}
	
#endif		
		</header>
	</addin>
</wxgrammar_generator_file>
