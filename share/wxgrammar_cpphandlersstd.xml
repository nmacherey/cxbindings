<?xml version="1.0" encoding="UTF-8"?>
<wxgrammar_generator_file lang="cpp">
	<var name="header_doc">
/** @file $(filename).h
 * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
 * This file is the handler for reading and writing $(object)'s into xml files.
 * @date $(date)
 */
	</var>
	<var name="src_doc">
/** @file $(filename).cpp
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * This file is the handler for reading and writing $(object)'s into xml files.
  * @date $(date)
  */
	</var>
	<var name="namespace_start">
namespace $(ns) {
	</var>
	<var name="namespace_end">
};
	</var>
	<var name="object_defines">
#ifndef $(OBJECT)XMLHANDLER_H
#define $(OBJECT)XMLHANDLER_H
	</var>
	<var name="object_defines_end">
#endif // $(OBJECT)XMLHANDER_H
	</var>
	<template name="object">
		<objectpart file="header">
$(header_doc)

$(object_defines)

/** @class $(object)XmlHandler
  * @brief Main class for reading and writing $(object) nodes information in xml files
  * @author Nicolas Macherey (nm@graymat.fr) http://www.rheia-framework.com
  * @date $(date)
  */
class $(exportmacro) $(object)XmlHandler : public stdXmlHandler
{
	DECLARE_DYNAMIC_CLASS_STD( $(object)XmlHandler )
public :
	/**********************************************************************
  	 * CONSTRUCTORS
	 *********************************************************************/

	/** Default Constructor */
	$(object)XmlHandler(): 
		stdXmlHandler()
	{};


	/**********************************************************************
  	 * METHODS
	 *********************************************************************/
	/** This one is called from CreateResource after variables
	  * were filled.
	  * Any handlers shall overload this metohd in order to complete the 
	  * child stuff.
	  */
	virtual stdObject *DoCreateResource();

	/** This is the method you have to overload to write a resource
	  * to anode simply create a new node and write info in
	  */
	virtual xmlNode* DoWriteResource();	

	/** @return Returns true if it understands this node and can create
	  * a resource from it, false otherwise.
	  */
	virtual bool CanHandle(xmlNode *node);
	
	/** @return Returns true if it understands this node and can create
	  * a resource from it, false otherwise.
	  */
	virtual bool CanHandle(const std::string&amp; className);

	/** @return Returns true if it understands the given resource and
	  * can write it into an xmlNode 
	  */
	virtual bool CanHandle( stdObject* resource );
};

$(object_defines_end)
		</objectpart>
		<objectpart file="src">
$(src_doc)

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;cstdio&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include "stdXmlReader.h"

#include "$(ns)_globals.h"

$(local_includes)

#include "$(object).h"
#include "handlers/$(object)XmlHandler.h"

IMPLEMENT_DYNAMIC_CLASS_STD( $(object)XmlHandler , stdXmlHandler )
stdREGISTER_XMLHANDLER( $(object)XmlHandler , "Handler for reading and writing $(object) nodes from an XML file" );

bool $(object)XmlHandler::CanHandle(xmlNode *node)
{
	if( node == NULL )
		return false;

	std::string nodeName = (char*) node-&gt;name;
	
	if( nodeName.compare( "$(object_node_name)" ) == 0 )
		return true;

	return false;
}

bool $(object)XmlHandler::CanHandle(const std::string&amp; className)
{	
	if( className.compare( "$(object)" ) == 0 )
		return true;

	return false;
}

stdObject *$(object)XmlHandler::DoCreateResource()
{
	stdMAKE_INSTANCE( $(object)Instance , $(object) );

$(objects_attribute_readers)
	
	xmlNode* childnode = m_node-&gt;children;	

	while( childnode != NULL )
	{
		std::string cname = (char*) childnode->name;
		
$(objects_property_readers)

		childnode = childnode-&gt;next;
	}

	return $(object)Instance;
}

xmlNode* $(object)XmlHandler::DoWriteResource()
{
	$(object)* $(object)Instance = dynamic_cast&lt;$(object)*&gt;(m_instance);

	xmlNode* node = xmlNewNode( NULL , (const xmlChar*) "$(object_node_name)" );
	xmlNode* childnode;
	
$(objects_attribute_writers)
	
$(objects_property_writers)

	return node;
}

bool $(object)XmlHandler::CanHandle(stdObject *resource)
{
	if( resource == NULL )
		return false;

	std::string className = resource->GetClassInfo()->GetClassName();
	
	if( className.compare( "$(object)" ) == 0 )
		return true;

	return false;
}
		</objectpart>
	</template>
	
	
	<!-- ATTRIBUTES READER AND WRITER TEMPLATES -->
	<template name="attribute_reader_string">
		<objectpart file="src">
	std::string $(name) = GetXmlAttr( m_node , "$(name)" );
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_int">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	int $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_enum">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	if( !$(name)str.empty() ) {
		$(type) $(name)Value;
		$(name)Value.SetValue($(name)str);
		$(object)Instance->Set$(name_extension)($(name)Value);
	}
		</objectpart>
	</template>
	<template name="attribute_reader_uint">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	unsigned int $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_long">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	long $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_ulong">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	long $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)((unsigned long)$(name));
		</objectpart>
	</template>
	<template name="attribute_reader_bool">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	
	bool $(name) = ( $(name)str.compare("true") == 0 );
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_double">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	double $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)($(name));
		</objectpart>
	</template>
	<template name="attribute_reader_float">
		<objectpart file="src">
	std::string $(name)str = GetXmlAttr( m_node , "$(name)" );
	
	std::stringstream strm;
	strm &lt;&lt; $(name)str;
	double $(name);
	strm &gt;&gt; $(name);
	$(object)Instance->Set$(name_extension)((float)$(name));
		</objectpart>
	</template>
	<template name="attribute_writer_string">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::string $(name) = $(object)Instance->Get$(name_extension)();
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)) ); 
	}
		</objectpart>
	</template>
	<template name="attribute_writer_int">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_enum">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)().GetValue();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_uint">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_long">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_ulong">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_bool">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::string $(name)str = $(object)Instance->Get$(name_extension)() ? "true" : "false";
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_double">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="attribute_writer_float">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewProp( node , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	
	<!-- PROPERTIES READER AND WRITER TEMPLATES -->
	<template name="property_reader_string">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name) = GetXmlContent( childnode );
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arraystring">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name) = GetXmlContent( childnode );
			$(object)Instance->Add$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_int">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			int $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arrayint">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			int $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Add$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_enum">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			$(type) $(name)Value;
			$(name)Value.SetValue($(name)str);
			$(object)Instance->Set$(name_extension)($(name)Value);
		}
		</objectpart>
	</template>
	<template name="property_reader_uint">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			unsigned int $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_long">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			long $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arraylong">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			long $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Add$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_ulong">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			long $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)((unsigned long)$(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arrayulong">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			long $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Add$(name_extension)((unsigned long)$(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_bool">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			bool $(name) = ( $(name)str.compare("true") == 0 );
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arraybool">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			bool $(name) = ($(name)str.compare("true") == 0);
			$(object)Instance->Add$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_double">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			double $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arraydouble">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			double $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Add$(name_extension)($(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_float">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			double $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Set$(name_extension)((float)$(name));
		}
		</objectpart>
	</template>
	<template name="property_reader_arrayfloat">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			std::string $(name)str = GetXmlContent( childnode );
			
			std::stringstream strm;
			strm &lt;&lt; $(name)str;
			double $(name);
			strm &gt;&gt; $(name);
			$(object)Instance->Add$(name_extension)((float)$(name));
		}
		</objectpart>
	</template>
	<template name="property_writer_string">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::string $(name) = $(object)Instance->Get$(name_extension)();
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)) ); 
	}
		</objectpart>
	</template>
	<template name="property_writer_arraystring">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;std::string&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i )
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)[i]) ); 
	}
		</objectpart>
	</template>
	<template name="property_writer_int">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayint">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;int&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_enum">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::string $(name)str = $(object)Instance->Get$(name_extension)().GetValue();
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_uint">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayuint">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;unsigned int&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_long">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		sstd::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arraylong">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;long&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_ulong">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayulong">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;unsigned long&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_bool">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::string $(name)str = $(object)Instance->Get$(name_extension)() ? "true" : "false";
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arraybool">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;bool&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::string $(name)str = $(name)[i] ? "true" : "false";
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_double">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arraydouble">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;double&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	<template name="property_writer_float">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		sstd::stringstream strm;
		strm &lt;&lt; $(object)Instance->Get$(name_extension)();
		std::string $(name)str;
		strm >> $(name)str;
		xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayfloat">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		std::vector&lt;float&gt;&amp; $(name) = $(object)Instance->Get$(name_extension)();
		for( unsigned int i = 0; i &lt; $(name).size() ; ++ i ) {
			std::stringstream strm;
			strm &lt;&lt; $(name)[i];
			std::string $(name)str;
			strm >> $(name)str;
			xmlNewChild( node , NULL , (const xmlChar*) "$(name)" , stdx2C($(name)str) );
		}
	}
		</objectpart>
	</template>
	
	<!-- OBJECT TEMPLATES -->
	
	<template name="property_reader_object">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			$(type)* $(name) = ($(type)*) CreateResFromNode(childnode,"$(type)",NULL);
			if( $(name) != NULL ) {
				$(object)Instance->Set$(name_extension)(*$(name));
				delete $(name);
			}
		}
		</objectpart>
	</template>
	<template name="property_reader_arrayobject">
		<objectpart file="src">
		if( cname.compare("$(name)") == 0 ) {
			$(type)* $(name) = ($(type)*) CreateResFromNode(childnode,"$(type)",NULL);
			if( $(name) != NULL ) {
				$(object)Instance->Add$(name_extension)(*$(name));
				delete $(name);
			}
		}
		</objectpart>
	</template>
	<template name="property_writer_object">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		childnode = stdXmlReader::Get()->WriteResource( &amp;($(object)Instance->Get$(name_extension)()) );
		if( childnode != NULL )
			xmlAddChild( node , childnode );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayobject">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		for( unsigned int i = 0; i &lt; $(object)Instance-&gt;Get$(name_extension)().size() ; ++i )
		{
			childnode = stdXmlReader::Get()->WriteResource( &amp;( $(object)Instance-&gt;Get$(name_extension)()[i] ) );
			if( childnode != NULL )
				xmlAddChild( node , childnode );
		}
	}
		</objectpart>
	</template>
	
	<!-- ANY TEMPLATES -->
	
	<template name="property_reader_any">
		<objectpart file="src">
		else if( !cname.IsEmpty() ) {
			stdObject* $(name) = CreateResFromNode(childnode,stdEmptyString,NULL);
			if( $(name) != NULL ) {
				wxAny anyObject = $(name);
				$(object)Instance->Set$(name_extension)(anyObject);
			}
		}
		</objectpart>
	</template>
	<template name="property_reader_arrayany">
		<objectpart file="src">
		else if( !cname.IsEmpty() ) {
			stdObject* $(name) = CreateResFromNode(childnode,stdEmptyString,NULL);
			if( $(name) != NULL ) {
				$(object)Instance->Add$(name_extension)($(name));
			}
		}
		</objectpart>
	</template>
	<template name="property_writer_any">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		childnode = stdXmlReader::Get()->WriteResource( $(object)Instance->Get$(name_extension)() );
		if( childnode != NULL )
			xmlAddChild( node , childnode );
	}
		</objectpart>
	</template>
	<template name="property_writer_arrayany">
		<objectpart file="src">
	if( $(object)Instance->Has$(name_extension)() ) {
		for( unsigned int i = 0; i &lt; $(object)Instance-&gt;Get$(name_extension)().size() ; ++i )
		{
			childnode = stdXmlReader::Get()->WriteResource( $(object)Instance-&gt;Get$(name_extension)()[i] );
			if( childnode != NULL )
				xmlAddChild( node , childnode );
		}
	}
		</objectpart>
	</template>
	
	<!-- OTHER TEMPLATES -->

	<!-- 
	 Type infos are used to notify the interpreter that the related types in the xml shall be
	 translated to the one given there.
	 It will consist into a map of elements specifying the source as a key and the destination
	 as a value.
	 If a type is not found it is assumed to be complex or to be generated in the file.
	-->
	<types_info>
		<typeinfo source="positiveInteger" destination="unsigned int"/>
		<typeinfo source="variant" destination="stdObject"/>
		<typeinfo source="string" destination="std::string"/>
		<typeinfo source="boolean" destination="bool"/>
		<typeinfo source="float" destination="double"/>
		<typeinfo source="integer" destination="int"/>
		<typeinfo source="dateTime" destination="std::string"/>
		<typeinfo source="duration" destination="std::string"/>
		<typeinfo source="datetime" destination="std::string"/>
		<typeinfo source="date" destination="std::string"/>
		<typeinfo source="time" destination="std::string"/>
		<typeinfo source="gYear" destination="std::string"/>
		<typeinfo source="gYearMonth" destination="std::string"/>
		<typeinfo source="gMonth" destination="std::string"/>
		<typeinfo source="gMonthDay" destination="std::string"/>
		<typeinfo source="ID" destination="unsigned int"/>
	</types_info>
	
	<addin name="stdXmlReader">
		<source>
/**
 * @file stdXmlReader.h
 * @brief main file for managing xml reading stuff for wxg
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#include &lt;libxml/xmlreader.h&gt;
#include &lt;libxml/xpath.h&gt;

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

#include "stdDefines.h"
#include "stdException.h"

#include "stdXmlReader.h"

IMPLEMENT_ABSTRACT_CLASS_STD( stdXmlHandler , stdObject );

/** Global instance for the stdXmlReader */
template&lt;&gt; stdXmlReader* stdSingleton&lt;stdXmlReader&gt;::instance = 0;

/** Global isShutdown initialization for the stdXmlReader */
template&lt;&gt; bool  stdSingleton&lt;stdXmlReader&gt;::isShutdown = false;

stdXmlReader::stdXmlReader()
{

}

stdXmlReader::~stdXmlReader()
{
	m_registeredHandlers.clear();

	for( unsigned int i = 0; i &lt; m_handlers.size(); ++i )
		delete m_handlers[i];

	m_handlers.clear();
}

stdObject* stdXmlReader::LoadFile( const std::string&amp; file )
{	
	m_doc = xmlParseFile( file.c_str() );
	
	if( m_doc == NULL )
		STD_THROW("Error cannot open document!");
	
	m_root = xmlDocGetRootElement( m_doc );
	
	if( m_root == NULL )
		STD_THROW("Error cannot get your document root !");
		
	std::string n_root = (char*) m_root-&gt;name;

	if( n_root.empty() )
		STD_THROW( "Error document root is empty" );

	/* Once we have extracted the root from the document, we have to 
   	 * find a handler which is able to return an object associated to
	 * this root.
	 */
	stdObject* resource = CreateResFromNode( m_root , stdEmptyString , NULL , NULL );
	
	xmlFreeDoc(m_doc);

	return resource;
}

void stdXmlReader::SaveFile( const std::string&amp; file , stdObject* resource )
{
	m_doc = xmlNewDoc((const xmlChar*) "1.0");
	
	if( m_doc == NULL )
		STD_THROW("Error cannot open document!");
	
	m_root = WriteResource( resource );
	
	if( m_root == NULL )
		STD_THROW("Error cannot get your document root !");
		
	xmlDocSetRootElement(m_doc,m_root);
	xmlSaveFormatFileEnc( file.c_str() , m_doc , "UTF-8" , 1 );
	
	xmlFreeDoc(m_doc);
}

bool stdXmlReader::HasHandlerFor( xmlNode* node )
{
	for( unsigned int i = 0 ; i &lt; m_handlers.size() ; ++i )
		if( m_handlers[i]-&gt;CanHandle( node ) )
			return true;

	return false;
}

stdObject *stdXmlReader::DoCreateResFromNode(xmlNode *node, const std::string&amp; className , stdObject *resource,stdXmlHandler *handlerToUse)
{
	if( handlerToUse != NULL )
		return handlerToUse-&gt;CreateResource( node , className , resource );

	stdObject* result = NULL;
	stdXmlHandler *handler = NULL;

	for( unsigned int i = 0; i &lt; m_handlers.size() ; ++i )
		if( m_handlers[i]-&gt;CanHandle( className ) ) {
			handler = m_handlers[i];
			break;
		}
	
	if( handler == NULL ) {
		for( unsigned int i = 0; i &lt; m_handlers.size() ; ++i )
			if( m_handlers[i]-&gt;CanHandle( node ) ) {
				handler = m_handlers[i];
				break;
			}
	}
	
	if( handler != NULL )
		result = handler-&gt;CreateResource( node , className , resource );

	return result;
}

xmlNode* stdXmlReader::DoWriteResource( stdObject* resource , stdXmlHandler* handlerToUse )
{
	if( handlerToUse != NULL )
		return handlerToUse-&gt;WriteResource( resource );

	xmlNode* node = NULL;

	for( unsigned int i = 0; i &lt; m_handlers.size() ; ++i )
		if( m_handlers[i]-&gt;CanHandle( resource ) ) {
			node = m_handlers[i]-&gt;WriteResource( resource );
			break;
		}

	return node;
}

std::vector&lt; std::string &gt; stdXmlReader::GetList()
{
	std::vector&lt; std::string &gt; ret;

	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.begin();
	for( ; it != m_registeredHandlers.end() ; ++it )
		ret.push_back(it-&gt;first);

	return ret;
}

std::vector&lt; std::string &gt; stdXmlReader::GetDescriptions()
{
	std::vector&lt; std::string &gt; ret;

	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.begin();
	for( ; it != m_registeredHandlers.end() ; ++it )
		ret.push_back(it-&gt;second.description);

	return ret;
}

bool stdXmlReader::RegisterXmlHandler( const std::string&amp; name,
		const std::string&amp; description,
		stdXmlHandlerConstructor ctor,
		stdXmlHandlerDestructor dtor )
{
	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.find(name);

	if( it != m_registeredHandlers.end() )
		return false;

	stdXmlHandlerRegistration info;
	info.name = name;
	info.description = description;
	info.ctor = ctor;
	info.dtor = dtor;

	m_registeredHandlers[name] = info;
	
	stdXmlHandler* handler = CreateXmlHandler( name );
	m_handlers.push_back( handler );

	return true;
}

bool stdXmlReader::UnregisterXmlHandler( const std::string&amp; name )
{
	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.find(name);

	if( it == m_registeredHandlers.end() )
		return false;
	
	RemoveHandlersOfClass( name );
	m_registeredHandlers.erase(it);
	return true;
}

stdXmlHandler* stdXmlReader::CreateXmlHandler( const std::string&amp; name )
{
	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.find(name);

	if( it == m_registeredHandlers.end() )
		return NULL;

	stdXmlHandler* handler = it-&gt;second.ctor( );
	return handler;
}

bool stdXmlReader::Exists( const std::string&amp; name )
{
	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.find(name);

	if( it == m_registeredHandlers.end() )
		return false;

	return true;
}

std::string stdXmlReader::GetDescription( const std::string&amp; name )
{
	stdXmlHandlerRegistrationMap::iterator it = m_registeredHandlers.find(name);

	if( it == m_registeredHandlers.end() )
		return stdEmptyString;

	return it-&gt;second.description;
}


void stdXmlReader::RemoveHandlersOfClass( const std::string&amp; classInfo )
{
	unsigned int i = 0;

	while( i &lt; m_handlers.size() ) {
		std::string className = m_handlers[i]-&gt;GetClassInfo()-&gt;GetClassName();

		if( className.compare( classInfo ) == 0 ) {
			delete m_handlers[i];
			stdArrayXmlHandler::iterator it = m_handlers.begin() + i;
			m_handlers.erase(it);
		}
		else {
			++i;
		}
	}
}

stdXmlHandler::stdXmlHandler():
	stdObject(),
	m_node(NULL),
	m_instance(NULL)
{
}

stdObject *stdXmlHandler::CreateResource(xmlNode *node, const std::string&amp; className , stdObject *instance)
{
    xmlNode *myNode = m_node;
    std::string myClass = m_class;
    stdObject *myInstance = m_instance;

    m_instance = instance;

    m_node = node;
    m_class = (char*) node-&gt;name;

    stdObject *returned = DoCreateResource();

    m_node = myNode;
    m_class = myClass;
    m_instance = myInstance;

    return returned;
}

xmlNode* stdXmlHandler::WriteResource( stdObject* resource )
{
	stdObject* myInstance = m_instance;

	m_instance = resource;

	xmlNode* node = DoWriteResource( );

	m_instance = myInstance;
	return node;
}

void stdXmlHandler::CreateChildren(bool this_hnd_only)
{
	xmlNode* child = m_node-&gt;children;
	while( child != NULL ) {

		if( stdXmlReader::Get()-&gt;HasHandlerFor( child ) )	
			stdXmlReader::Get()-&gt;DoCreateResFromNode(child, stdEmptyString, NULL, this_hnd_only ? this : NULL);
		
		child = child-&gt;next;
	}
}


void stdXmlHandler::CreateChildrenPrivately(xmlNode *rootnode)
{
	xmlNode *root;
	if (rootnode == NULL) root = m_node; else root = rootnode;
	xmlNode *n = root-&gt;children;

	while (n != NULL)
	{
		if (CanHandle(n))
		{
			CreateResource(n,stdEmptyString, NULL);
		}
		n = n-&gt;next;
    }
}
		</source>
		<header>
/**
 * @file stdXmlReader.h
 * @brief main file for reading an xml file
 * @author Nicolas Macherey (nm@graymat.fr)
 * @version 10.4
 */
#ifndef STD_XMLREADER_H
#define STD_XMLREADER_H

#include "stdSingleton.h"
#include "stdDefines.h"
#include "stdException.h"
#include "stdObject.h"

/* imports */
class stdXmlHandler;
class stdXmlReader;
class stdObject;

/** define XmlHandler constructor methods for building generically any kind of handlers */
typedef stdXmlHandler* (*stdXmlHandlerConstructor)();

/** define XmlHandler destructor methods for freeing any created handler */
typedef void (*stdXmlHandlerDestructor)(stdXmlHandler*);

/** define an array of stdXmlHandler */
typedef std::vector&lt; stdXmlHandler* &gt; stdArrayXmlHandler;

/** @struct stdXmlHandlerRegistration
  * @brief main strcuture for storing registration information about the
  * construction and destrcution of a stdXmlHandler.
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
struct stdXmlHandlerRegistration
{
	/****************************************************************
	  * STRUCTURE ACCESSORS
	  **************************************************************/
	/** default constructor */
	stdXmlHandlerRegistration( ) : 
		ctor(0),dtor(0)
	{};

	/** copy constructor */
	stdXmlHandlerRegistration( const stdXmlHandlerRegistration&amp; rhs ):
		name(rhs.name),
		description(rhs.description),
		ctor(rhs.ctor),
		dtor(rhs.dtor)
	{};

	/** operator= overload */
	stdXmlHandlerRegistration&amp; operator=(const stdXmlHandlerRegistration&amp; rhs)
	{
		name = rhs.name;
		description = rhs.description;
		ctor = rhs.ctor;
		dtor = rhs.dtor;
		return (*this);
	}


	/****************************************************************
	  * PROPERTIES
	  **************************************************************/
	std::string name;
	std::string description;
	stdXmlHandlerConstructor ctor;
	stdXmlHandlerDestructor dtor;
};

/** now we just have to define a map of stdXmlHandlerRegistration in order to manage them in
  * the stdXmlReader.
  */
typedef std::map&lt; std::string , stdXmlHandlerRegistration &gt; stdXmlHandlerRegistrationMap;

/** @class stdXmlReader
  * @brief Main class for reading an xml file in wxg and in generated files
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
class stdXmlReader : public stdSingleton&lt;stdXmlReader&gt;
{
	friend class stdSingleton&lt;stdXmlReader&gt;;
	friend class stdXmlHandler;

public :
	/*******************************************************************************
    	*   ACCESSORS
    	*******************************************************************************/

    	/** Get the list of registered handlers in this manager
    	  * This will provide you with an array string of registered object names
    	  * but not with their description, if you need to get the list of handlers
	  * descriptions you should call stdXmlReader::GetDescriptions. Please
	  * note that this list might change at run time as this factory is made
	  * for adding and removing handlers dynamically.
    	  */
	std::vector&lt; std::string &gt; GetList();

	/** Get all descriptions associated to each registered handler. Please
	  * note that this list might change at run time as this factory is made
	  * for adding and removing handlers dynamically.
	  */
	std::vector&lt; std::string &gt; GetDescriptions();

	/** Register a handler in the factory.
	  * Each handler can only be registered once.
	  * Please see the stdXmlHandlerRegistrant object in order
	  * to know how to register a new handler in this factory.
	  * @param name handler name
	  * @param description handler's description
	  * @param ctor handler constructor function pointer
	  * @param dtor handler destructor function pointer
	  * @return false if the handler already exists in this factory !
	  */
	bool RegisterXmlHandler( const std::string&amp; name,
			const std::string&amp; description,
			stdXmlHandlerConstructor ctor,
			stdXmlHandlerDestructor dtor );

	/** Unregister indicator from that factory,
	  * Once you have call this method the handler will not be available
	  * in this factory.
	  */
	bool UnregisterXmlHandler( const std::string&amp; name );

	/** Creates a handler accordingly to it's name
	  * You can call this method at any time if you want to create a handler
	  * from it's name only.
	  * @param name handlers name
	  * @param g wxg on which the handler will work
	  * @param interpreter wxgInterpreter interpreter for generating the code
	  * @return the requested handler instance if exists NULL if it is not existing
	  */
	stdXmlHandler* CreateXmlHandler( const std::string&amp; name );

	/** Check the existence of a handler by it's name
	  * @param name handler name to check the existance for
	  * @return false if the handler is not registered in the factory
	  */
	bool Exists( const std::string&amp; name );
	
	/** Find the description associated to the handler name
	  * @param name handler's name to find the description for
	  * @return a stdEmptyString if the handler does not exists in the factory
	  */
	std::string GetDescription( const std::string&amp; name );

	/** Remove all handlers associated to the given class from
	  * the global array
	  * @param classInfo class info of the handlers to remove
	  */
	void RemoveHandlersOfClass( const std::string&amp; classInfo );

	/** This is the main stuff of that manager. when you need to read an xml file
	  * using wxgxmlReader, you shall always use this method.
	  * It is taking in input the xml file path to read and returns a stdObject
	  * in output.
	  * The stdObject shall corresponds to your root node of your xml file.
	  */
	stdObject* LoadFile( const std::string&amp; file );
	
	/** Save the resource in the given file 
	 * @param file file in which the resource shall be saved 
	 * @param resource resrouce to save in the file 
	 */
	void SaveFile( const std::string&amp; file , stdObject* resource );

	/** This is a convenience function made for helping stdXmlHandler's to
	  * load resource from children of theirs but which they cannot handle.
	  */
	stdObject *CreateResFromNode(xmlNode *node , const std::string&amp; className, stdObject *resource = NULL, stdXmlHandler* handlerToUse = NULL)
	{
		return node ? DoCreateResFromNode(node , className , resource, handlerToUse)
			: NULL;
	}


	/** Check if the given xmlNode can be handled or not */
	bool HasHandlerFor( xmlNode* node );

	/** This method is used to write resource to into a node */
	xmlNode* WriteResource( stdObject* resource , stdXmlHandler* handlerToUse = NULL )
	{
		return resource ? DoWriteResource(resource, handlerToUse)
			: NULL;
	}


private :
	/***********************************************************************************
	  * CONSTRUCTOR AND DESTRUCTOR
	  *********************************************************************************/
	/** Default constructor,
	  * You cannot build directly this class, this class is a global singleton 
	  * you have to use stdXmlReader::Get() to access the global instance 
	  * of this class.
	  */
	stdXmlReader();

	/** Default destructor
	  * You shall never have to destroy this class by your own unless you are an
	  * application developper. Anyway if you want to free the global instance of this manager
	  * properly, you have to call stdXmlReader::Free() to free it's global instance
	  */
	~stdXmlReader();

	/** Creates a stdObject from a node */
	stdObject *DoCreateResFromNode(xmlNode* node,
				  const std::string&amp; className,
                                  stdObject *resource,
                                  stdXmlHandler *handlerToUse = NULL);

	/** This method is used to write resource to into a node */
	xmlNode* DoWriteResource( stdObject* resource , stdXmlHandler* handlerToUse = NULL );

	/** container of all registered handlers */
	stdXmlHandlerRegistrationMap m_registeredHandlers;
	
	/** container of all allocated handlers */
	stdArrayXmlHandler m_handlers;

	/** XML document */
	xmlDoc* m_doc;

	/** XML root node */
	xmlNode* m_root;
};

/**
  * @class stdXmlHandler
  * @brief Abstract class for defining a wxg xml handler
  * 
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
class stdXmlHandler : public stdObject
{
	DECLARE_ABSTRACT_CLASS_STD(stdXmlHandler)
	
	/** give stdXmlReader our private members access */
	friend class stdXmlReader;

public :
	/** Default constructor */
	stdXmlHandler();
	
	/** Destructor */
	virtual ~stdXmlHandler()
	{};

   	/** Creates an object any kind of stdObject that can be created using
	  * a stdXmlHandler.
	  * Any handler provides stdXmlReader with a set of methods to
	  * notify if the given resource can be created from a node or not.
	  * the system is quite similar to the wxWidgets XRC system excepts
	  * that any kind of nodes can be handled and not necessarily objects
	  * node from your xml file.
	  * Any way from that information the handler shall be able to create
	  * it's resource from a node. This is the place to do it !
	  */
    	stdObject *CreateResource(xmlNode *node, const std::string&amp; className, stdObject *instance);

	/** Write the given resource in the given parent node
	  * This method is used to write an xml document using the
	  * stdXmlReader system.
	  * The system simply ask the handler to write the given object in
	  * a new node, this node will then be added in the parent properly.
	  * each handler which is handling child nodes will have to add the
	  * returned node if not NULL to its xml tree.
	  */
	xmlNode* WriteResource( stdObject* resource );

    	/** This one is called from CreateResource after variables
    	  * were filled.
	  * Any handlers shall overload this metohd in order to complete the 
	  * generation stuff.
	  */
    	virtual stdObject *DoCreateResource() = 0;

	/** This is the method you have to overload to write a resource
	  * to anode simply create a new node and write info in
	  */
	virtual xmlNode* DoWriteResource() = 0;

    	/** @return Returns true if it understands this node and can create
    	  * a resource from it, false otherwise.
	  */
    	virtual bool CanHandle(xmlNode *node) = 0;

	/** @return Returns true if it understands this node and can create
    	  * a resource from it, false otherwise.
	  */
    	virtual bool CanHandle(const std::string&amp; className) = 0;

	/** @return Returns true if it understands the given resource and
	  * can write it into an xmlNode 
	  */
	virtual bool CanHandle( stdObject* resource ) = 0;

protected:
    	// Variables (filled by CreateResource)
    	xmlNode *m_node;
    	std::string m_class;
    	stdObject *m_instance;

protected:
	/** Creates children. */
	void CreateChildren(bool this_hnd_only = false);

	/** Helper function. */
	void CreateChildrenPrivately(xmlNode *rootnode = NULL);

	/** Creates a resource from a node. */
	stdObject *CreateResFromNode(xmlNode *node,
			const std::string&amp; className,
			stdObject *instance = NULL)
	{ return stdXmlReader::Get()-&gt;CreateResFromNode(node, className, instance); }		
};

/** define a macro for helping creating the instance inside a wxXmlHandler :D */
#define stdMAKE_INSTANCE(variable, classname) \
   classname *variable = NULL; \
   if (m_instance) \
       variable = static_cast&lt;classname*&gt;(m_instance); \
   if (!variable) \
       variable = new classname;

/**
  * @class stdXmlHandlerRegistrant
  * @brief this main template allows you to register easily your stdXmlHandler in the stdXmlReader
  * 
  * Assuming that your handler has the following name : MyXmlHandler , an example could be :
  * @code 
  *	namespace {
  *		stdXmlHandlerRegistrant&lt;MyXmlHandler&gt; registrant( "MyXmlHandler" , "Description of my handler";
  *	};
  * @endcode
  * This shall be done in the top of MyXmlHandler.cpp file.
  * I also wrote a helper in order to write it faster :
  * @code
  * stdREGISTER_XMLHANDLER( MyXmlHandler , "Description of my XmlHandler" );
  * @endcode
  *
  * @author Nicolas Macherey (nm@graymat.fr)
  * @date 8-May-2010
  */
template&lt;class T&gt; class stdXmlHandlerRegistrant
{

public :
	stdXmlHandlerRegistrant( const std::string&amp; name , const std::string&amp; description ):
		m_name(name)
	{
		/* The main task is to call the stdXmlReader and to register the handler in 
		 * using our two satic method that will be used to register in the factory */
		stdXmlReader::Get()-&gt;RegisterXmlHandler( name , description , &amp;Create , &amp;Free );
	}
	
	~stdXmlHandlerRegistrant()
	{
		/* if the factory is down this means that the instance has already been removed from it */
		if(!stdXmlReader::IsDown()) 
			stdXmlReader::Get()-&gt;UnregisterXmlHandler( m_name );
	};
	
	/** The create method is made static, so that the program knows the adress of that method without the
	  * need of making a functor or something complicated.
	  * this method will correspond to the stdXmlHandlerConstructor pointer 
	  */
	static stdXmlHandler* Create( )
	{
		return new T( );
	}

	/** The free method is made static so that the program knows its adress. It corresponds to the 
	  * stdXmlHandlerDestructor function pointer
	  */
	static void Free( stdXmlHandler* handler )
	{
		delete handler;
	}

private :
	std::string m_name;
};

#define stdREGISTER_XMLHANDLER( object , description ) \
	namespace ns##object { \
		stdXmlHandlerRegistrant&lt;object&gt; registrant( #object , description ); \
	};

#endif
		</header>
	</addin>
</wxgrammar_generator_file>
